// Code generated by protoc-gen-go-nexus. DO NOT EDIT.
// versions:
//
//	protoc-gen-go-nexus dev (latest)
//	go go1.24.0
//	protoc (unknown)
//
// source: proto/v1/service.proto
package greetingnexus

import (
	"context"
	nexusproto "github.com/nexus-rpc/sdk-go/contrib/nexusproto"
	nexus "github.com/nexus-rpc/sdk-go/nexus"
	v1 "nexus-exp/gen/proto/v1"
)

// GreetingServiceName defines the fully-qualified name for the greeting.v1.Greeting service.
const GreetingServiceName = "greeting.v1.Greeting"

// GreetingGreetOperationName defines the fully-qualified name for the Greet operation.
const GreetingGreetOperationName = "Greet"

var GreetingGreetOperation = nexus.NewOperationReference[*v1.GreetInput, *v1.GreetOutput](GreetingGreetOperationName)

// GreetingSlothGreetOperationName defines the fully-qualified name for the SlothGreet operation.
const GreetingSlothGreetOperationName = "SlothGreet"

var GreetingSlothGreetOperation = nexus.NewOperationReference[*v1.SlothGreetInput, *v1.SlothGreetOutput](GreetingSlothGreetOperationName)

type GreetingNexusHandler interface {
	Greet(name string) nexus.Operation[*v1.GreetInput, *v1.GreetOutput]
	SlothGreet(name string) nexus.Operation[*v1.SlothGreetInput, *v1.SlothGreetOutput]
}

func NewGreetingNexusService(h GreetingNexusHandler) (*nexus.Service, error) {
	svc := nexus.NewService(GreetingServiceName)
	err := svc.Register(h.Greet(GreetingGreetOperationName), h.SlothGreet(GreetingSlothGreetOperationName))
	if err != nil {
		return nil, err
	}
	return svc, nil
}

type UnimplementedGreetingNexusHandler struct{}
type unimplementedGreetingGreet struct {
	nexus.UnimplementedOperation[*v1.GreetInput, *v1.GreetOutput]
	name string
}

func (h *unimplementedGreetingGreet) Name() string {
	return h.name
}
func (h *UnimplementedGreetingNexusHandler) Greet(name string) nexus.Operation[*v1.GreetInput, *v1.GreetOutput] {
	return &unimplementedGreetingGreet{
		name: name,
	}
}

type unimplementedGreetingSlothGreet struct {
	nexus.UnimplementedOperation[*v1.SlothGreetInput, *v1.SlothGreetOutput]
	name string
}

func (h *unimplementedGreetingSlothGreet) Name() string {
	return h.name
}
func (h *UnimplementedGreetingNexusHandler) SlothGreet(name string) nexus.Operation[*v1.SlothGreetInput, *v1.SlothGreetOutput] {
	return &unimplementedGreetingSlothGreet{
		name: name,
	}
}

type GreetingNexusHTTPClient struct {
	client nexus.HTTPClient
}

// NewGreetingNexusHTTPClient initializes a new GreetingNexusHTTPClient.
// options.Service is overridden with the defined proto service name.
func NewGreetingNexusHTTPClient(options nexus.HTTPClientOptions) (*GreetingNexusHTTPClient, error) {
	options.Service = GreetingServiceName
	if options.Serializer == nil {
		options.Serializer = nexusproto.NewSerializer(nexusproto.SerializerOptions{
			Mode: nexusproto.SerializerModePreferJSON,
		})
	}
	client, err := nexus.NewHTTPClient(options)
	if err != nil {
		return nil, err
	}
	return &GreetingNexusHTTPClient{
		client: *client,
	}, nil
}

type GreetingGreetOperationStartResult struct {
	Successful *v1.GreetOutput
	Pending    *nexus.OperationHandle[*v1.GreetOutput]
	Links      []nexus.Link
}

func (c *GreetingNexusHTTPClient) GreetAsync(ctx context.Context, input *v1.GreetInput, options nexus.StartOperationOptions) (*GreetingGreetOperationStartResult, error) {
	res, err := nexus.StartOperation(ctx, &c.client, GreetingGreetOperation, input, options)
	if err != nil {
		return nil, err
	}
	typed := GreetingGreetOperationStartResult{
		Successful: res.Successful,
		Pending:    res.Pending,
		Links:      res.Links,
	}
	return &typed, nil
}
func (c *GreetingNexusHTTPClient) Greet(ctx context.Context, input *v1.GreetInput, options nexus.ExecuteOperationOptions) (*v1.GreetOutput, error) {
	output, err := nexus.ExecuteOperation(ctx, &c.client, GreetingGreetOperation, input, options)
	return output, err
}
func (c *GreetingNexusHTTPClient) NewGreetHandle(id string) (*nexus.OperationHandle[*v1.GreetOutput], error) {
	return nexus.NewHandle(&c.client, GreetingGreetOperation, id)
}

type GreetingSlothGreetOperationStartResult struct {
	Successful *v1.SlothGreetOutput
	Pending    *nexus.OperationHandle[*v1.SlothGreetOutput]
	Links      []nexus.Link
}

func (c *GreetingNexusHTTPClient) SlothGreetAsync(ctx context.Context, input *v1.SlothGreetInput, options nexus.StartOperationOptions) (*GreetingSlothGreetOperationStartResult, error) {
	res, err := nexus.StartOperation(ctx, &c.client, GreetingSlothGreetOperation, input, options)
	if err != nil {
		return nil, err
	}
	typed := GreetingSlothGreetOperationStartResult{
		Successful: res.Successful,
		Pending:    res.Pending,
		Links:      res.Links,
	}
	return &typed, nil
}
func (c *GreetingNexusHTTPClient) SlothGreet(ctx context.Context, input *v1.SlothGreetInput, options nexus.ExecuteOperationOptions) (*v1.SlothGreetOutput, error) {
	output, err := nexus.ExecuteOperation(ctx, &c.client, GreetingSlothGreetOperation, input, options)
	return output, err
}
func (c *GreetingNexusHTTPClient) NewSlothGreetHandle(id string) (*nexus.OperationHandle[*v1.SlothGreetOutput], error) {
	return nexus.NewHandle(&c.client, GreetingSlothGreetOperation, id)
}
